import java.util.*;

public class Main {

    public static final int DEBUG_LEVEL = 1; // Set the debug level for the application
    private static SimpleDebug debugger = new SimpleDebug(DEBUG_LEVEL);

    public static void main(String[] args) throws Exception {
        String input = """
            { // some comment
             /* multi-line comment */
                function myFunction(int x, int y): int {
                    int z = x;
                    return z;
                }

                struct myStruct {
                    int a;
                    int b;
                }

                implement myStruct {
                    function myFunction(int x, int y): int {
                        int z = x;
                        return z;
                    }
                }

                int i = 0;

                for(3) {
                    inc(i);
                    out(i);
                }

                for(i) {
                    out(i);
                    i = i + 1;
                }

                {
                    {
                        out(2);
                        i = 2;
                        i = 2 + 3;
                        i = i + 1;
                        i = i + i + 2;
                        i = (i + 1) * (i / 2);
                    }
                }

                namedScope {
                    int a = 5;
                    dec(a);
                    out(a);
                    jump(namedScope);
                }
            }
        """;

        // Debugging: Start lexer
        debugger.debug("Starting lexer...", 1);
        Lexer lexer = new Lexer();
        List<Lexer.Token> tokens = lexer.tokenize(input);
        debugger.debug("Lexer completed. Tokens generated.", 1);

        // Debugging: Display tokens
        debugger.info(1, "Tokens:");
        tokens.forEach(token -> debugger.info(2, token.toString()));

        // Debugging: Start parser
        debugger.debug("Starting parser...", 1);
        Parser parser = new Parser(tokens);
        Parser.Node[] nodes = parser.parse();
        debugger.debug("Parser completed. Nodes generated.", 1);

        // Debugging: Display parsed nodes
        debugger.info(1, "\nParsed Nodes:");
        for (Parser.Node node : nodes) {
            debugger.info(2, node.toString());
        }

        // Debugging: Ensure AST printing is reached
        debugger.debug("Preparing to print the AST...", 1);

        debugger.debug("Number of nodes in AST: " + (nodes != null ? nodes.length : "null"), 1);
        if (nodes == null || nodes.length == 0) {
            debugger.error("No nodes were generated by the parser.", 1);
            return; // Exit early if no nodes are available
        }

        // Debugging: Log each node in the array
        for (int i = 0; i < nodes.length; i++) {
            debugger.debug("Node " + i + ": " + nodes[i], 2);
        }

        // Print the AST after validation
        debugger.info(1, "\nAbstract Syntax Tree (AST):");
        for (Parser.Node node : nodes) {
            printAST(node, 0);
        }

        debugger.debug("AST printing completed.", 1);
    }

    // Recursive method to pretty-print the AST
    private static void printAST(Parser.Node node, int depth) {
        if (node == null) {
            debugger.error("Encountered a null node in the AST.", 2);
            return;
        }

        // Indent based on the depth of the node
        String indent = "  ".repeat(depth);

        // Pretty-print the current node
        System.out.println(indent + SimpleColor.WARNING(node.type) + SimpleColor.DEBUG(": ") + SimpleColor.INFO(node.value));

        // Debugging: Log the number of children
        debugger.debug("Node '" + node.type + "' has " + node.children.size() + " children.", 3);

        // Recursively pretty-print child nodes
        for (Parser.Node child : node.children) {
            printAST(child, depth + 1);
        }
    }
}

/*

Scopes are defined by the curly braces.
Scopes can have a keyword which defines the type of scope, or names if it isn't a reserved keyword
Scopes can have parameters, which are passed to the scope when it is reached or called.
Scopes can have scoped variables, which are only accessible within the scope they are defined in, and are destroyed when the scope ends.
Scopes can access variables within higher scopes and the parameters passed to them.
Scopes can be nested, and can be called from within other scopes.

Reserved scope keywords: function, for, struct, implement
Reserved type keywords: int
Reserved operator keywords: out, inc, dec, jump

// whitespace is always ignored

// Operator statement definition
<operator_keyword> <(> [<identifier>|<literal>]* <)> <;>

// function call statement definition
<identifier> <(> [[<identifier>|<literal>] [<,> <identifier>|<literal>]*]? <)> <;>

// variable statement definition
<type_keyword> <identifier> <=> [<value>|<identifier>] <;>

// parameter scope definition
<(> [[<type_keyword> <identifier>] [<,> <type_keyword> <identifier>]*]? <)>

// function scope definition
function <identifier> <parameter_scope> <:> <type_keyword> <{>
[<statement>|<scope>]*
return [<identifier>|<value>] <;>
<}>

// for loop scope definition
for <(> [<identifier>|<literal>] <)> <{>
[<statement>|<scope>]*
<}>

// struct scope definition
struct <identifier> <{>
[<type_keyword> <identifier> <;>]+
<}>

// implement scope definition
implement <identifier> <{>
[<function> <;>]+
<}>

// scope definition
<identifier>? <{>
[<statement>|<scope>]*
<}>

*/